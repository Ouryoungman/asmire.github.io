<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Notes-Representation Learning on Graphs: Methods and Applications]]></title>
    <url>%2F2019%2F07%2F26%2FNotes-Representation-Learning-on-Graphs-Methods-and-Applications%2F</url>
    <content type="text"><![CDATA[Representation Learning on Graphs: Methods and Applications. 作者：William L. Hamilton, Rex Ying 论文地址: https://arxiv.org/pdf/1709.05584.pdfhe 摘要在不同图（Graph）上的机器学习是一项重要且无处不在的任务，其应用范围从药物设计到社交网络中的好友推荐。该领域的主要挑战是找到一种方法来表 示或编码图结构，以便机器学习模型可以轻松利用它。传统的机器学习方法依赖于用户定义的启发式方法来提取编码关于图的结构信息的特征（例如，度数统计或内核 函数）。然而，近年来，使用基于深度学习和非线性降维的技术，自动学习将图结构编码为低维嵌入的方法出现了激增。在这里，我们提供了关于图形表示学习领域进 展的关键概念回顾，包括基于矩阵分解的方法，基于随机游走的算法和图形卷积网络。文中回顾了嵌入单个节点的方法以及嵌入整个（子）图的方法。为此，制定了一 个统一的框架来描述这些最新的方法，并且强调了未来工作的一些重要应用和方向。 论文笔记Introduction对于图的机器学习，其核心问题是找到一种方法，将有关图结构的信息纳入机器学习模型。而其面临的挑战在于没有一种直接方法将高维非欧的图结构信息转换为特征向量。 传统方法用预处理方法来提取结构信息。常见的方法有：图统计信息(e.g. 度(degree)或聚类系数(clustering coefficients))，核方法(Kernel function/method)，特征工程(feature engineering)。但是他们测量邻结构往往有着诸多限制。这是因为他们的方法是通用性弱(inflexible)，在学习过程中不能适应，并且耗费大量时间与财力。 随着机器学习发展，网络表征学习被提出。其背后思想是通过学习将节点或整个(子)图作为点嵌入到低维向量空间 $\mathbb{R}^d$ 中。目标是优化这个映射，使嵌入空间中的几何关系反映原始图的结构。 与传统方法相比，网络表征学习将此问题视为机器学习任务本身，使用数据驱动方法来学习编码图结构的嵌入。 Notation and essential assumptionAssume: 无向图 $G = (V ,\varepsilon)$ 与二值邻接矩阵 $A$ 节点属性的实值矩阵 $X \in \mathbb{R}^{m \times \vert V \vert}$ Goal :使用$A$和$X$中包含的信息将每个节点或子图映射到向量$z\in \mathbb{R}^d$，其中$d &lt;&lt; \vert V\vert$。 Embedding nodes]]></content>
      <categories>
        <category>NRL/RL/GL</category>
        <category>Survey</category>
      </categories>
      <tags>
        <tag>NRL/RL/GL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Relation Algebra]]></title>
    <url>%2F2019%2F07%2F24%2FRelation-algebra%2F</url>
    <content type="text"><![CDATA[Overview of the relational algebra It provides a series of operations including Union, Intersection, Difference, Cartesian Product, Project, Select, Join and Division based on sets. The opertors take one or more relations as inputs and give a new relation as a result. Procedural languageFor example : $\prod_{Sno,Cname}(\sigma_{Cno = “002”}(Student\bowtie SC))$ An abstract language, and is the foundation to learn SQL. Traditional Relational Algebra Operations [only involve row] Operation Relation R Relation S Notation UNION $R$ $S$ $R \cup S$ INTERSECTION $R$ $S$ $R \cap S$ DIFFFERENCE $R$ $S$ $R-S$ Cartesian PRODUCT $R$ $S$ $R \times S$ Special Relational Algebra Operations [involve row and column] Operation Relation R Relation S Notation PROJECT $R$ $\pi_{A}(R)$ SELECT $R$ $\sigma_{Con}(R)$ JOIN $R$ $S$ $R \mathop{\Join}\limits_{A \ \theta \ B} S$ Cartesian PRODUCT $R$ $S$ $R \div S$ Compatibility for the relational algebra The relations involved in Union, Intersection and Difference must be compatible(相容的) to ensure above relational algebra operations to be valid Relation $R$ and relation $S$ are compatible when$[1]$ $R$,$S$ must have the same arity(同元的, same number of attributes)$[2]$ The attribute domains must be compatible (e.g., the $2^{nd}$ column of $S$.) For relation $R(A_1,A_2,…,A_n)$ and relation $S(B_1,B_2,…,B_m)$,IF $R$ and $S$ are compatible,Then $n = m$ and Domain$(A_i)$ = Domain$(B_i)$, $i=1,2,…,n$ Relational algebra (1) : Union Notation: $R \cup S$ Defined as: $R \cap S$ = $\lbrace t\ |\ t \in R \vee t \in S \rbrace$ For $R \cup S$ to be valid, $R$ and $S$ should be compatible $R \cup S $ = $S \cup R$ Relational algebra (2) : Difference Notation: $R - S$ Defined as: $R-S = \lbrace t \ | \ t \in R \land t \notin S \rbrace$ For $R-S$ to be valid, R and S should be compatible $R - S \ne S - R$ Relational algebra (3) : Intersection Notation: $R \cap S$ Defined as: $R \cap S$ = $\lbrace t \ | \ t \in R \land t \in S \rbrace$ For $R \cap S$ to be valid, R and S should be compatible $R \cap S$ = $S \cap R$ $R \cap S$ = $R - (R-S)$ = $S - (S - R)$ Relational algebra (4) : Cartesian Product Notation: $R \times S$ Defined as: $R \times S$ = $\lbrace t,q \ |\ t \in R \land q \in S \rbrace$ $R \times S$ = $S \times R$ If the defree of $R$ is $n$, and the degree of $S$ is $m$, then the degree of $R \times S$ is $n + m$ If the cardinality of $R$ is $n$, and the cardinality of $S$ is $m$, then the cardinality of $R \times S$ is $n \times m$. Relational algebra (5) : Select Notation: $\sigma_p(R)$ $p$ is called the selection predicate (选择谓词) Defined as: $\sigma_p(R)$ = $\lbrace t \ | \ t \in R \land p(t) \rbrace$where $p$ is a formula in propositional calculus(命题演算) consisting of terms connected by: $\land (and), \lor (or),\lnot (not)$Each term is one of: &lt;$attribute$&gt; $op$ &lt;$attribute$&gt; or &lt;$constant$&gt;where $op$ is obne of: $=,\ne,\gt,\ge,\lt,\le$ Usually, there are many operators in the selection predicate $p$, and the priority sequence is as following: () [Parentheses] $=,\ne,\gt,\ge,\lt,\le$ $\lnot$ $\land$ $\lor$ Relational algebra (6) : Project Notation : $\prod _{A_1,A_2,…,A_k}(R)$where $A_1$,$A_2$,…,$A_k$ are attribute names and $R$ is a relation name. The result is defined as the relation of $k$ columns obtained by erasing the columns that are not listed Duplicate rows removed from result, since relations are sets Ralational algebra (7) : Join$\theta$-Join Notation: $R \mathop{\Join}\limits_{A \ \theta \ B} S$ Defined as: $R\mathop{\Join}\limits_{A \ \theta \ B} S = \sigma _{t[A] \ \theta \ s[B]}(R \times S)$ $R(A_1,A_2,…,A_n)$, $A \in \lbrace A_1,A_2,…A_n \rbrace$ $S(B_1,B_2,…,B_m)$, $B \in \lbrace B_1,B_2,…B_m \rbrace$ $t \in R$, $s \in S$ $A$ and $B$ are compatible $\theta \in \lbrace \gt,\ge,\lt,\le,=,&lt;&gt; \rbrace$ $\theta$-Join usually used with Select and Project together. Rename Notation: $\rho$ Rename a relation to another with a different name Duplicate a relation and give a new name $R_1 \rightarrow R_2$, and only the relation names are different for R_1 and R_2 Query: Select all course No.s which both “2015030101” and “2015040101” from relation SC have taken. Answer: $\pi_{SC.Cno = “2015030101” \lor SC1.Sno = “2015040101”}(SC \mathop{\Join}\limits_{SC.Cno = SC1.Cno} \rho_{SC1}(SC))$ Equal-Join Notation: $R\mathop{\Join}\limits_{A=B} S$ Defined as: $R\mathop{\Join}\limits_{A=B}S = \sigma_{t[A]=sB}$ $R(A_1,A_2,…,A_n),A\in \lbrace A_1,A_2,…,A_n \rbrace$ $S(B_1,B_2,…,B_m),B\in \lbrace B_1,B_2,…,B_m \rbrace$ $t \in R, s \in S$ $A$ and $B$ are compatible Equal-Join is a special case of $\theta$-Join Natural-Join Notation: $R \Join S$ Defined as: $R \Join S = \sigma_{t[B]=s[b]}(R\times S)$ $R$ and $S$ have one same attribute or a group of same attributes Duplicated columns should be deleted in the result relation Equal-Join is a special case if $\theta $-Join Outer-Join An etension of the join operation that avoids loss of information Computes the join and then adds tuples from one relation that does not match tuples in the other relation to the result of the join User null values: null signifies that the value is unknown or does not exist Notation: Left-Join: ⟕ Right-Join: ⟖ Full-Join: ⟗ Ralational algebra (8) : Divisiojn Notation: $R \div S$ $R = (A_1,…,A_m,B_1,…,B_n)$ $S = (B_1,…,B_n)$ $S \subseteq R$ Each attribute of schema $S$ is also in schema $R$ The result of $R \div S$ is a relation schema, and containing all attributes of $R$ that are not in $S$.$R - S = (A_1,…,A_m)$ Suited to queries that include the phrase “for all” $R \div S = \lbrace t \ |\ t \in \prod _{R-S}(R) \land \forall u \in S(tu \in R)\rbrace$]]></content>
      <categories>
        <category>Database concept</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database Concept]]></title>
    <url>%2F2019%2F07%2F24%2FDatabase-concept%2F</url>
    <content type="text"><![CDATA[Databases, DBMS and Database SystemsDatabasesWhat is a database? A very large, integrated collection of data The amount of data is very large The data is structured and interrelated The data is integrated Models real-world enterprises or oraganizations Entities (e.g., students, courses) Relationships (e.g., Li is taking Database and Knowledge) Databases touch all aspects of our lives Database Applications Banking: customer information, accounts, loans, and banking transactions Airlines: reservations, schedules Universities: students, registration, grades Sales: customers, products, purchases Manufacturing: production, inventory, orders, supply chain Human resources: employee records, salaries, tax deductions Database Management System (DBMS)DefinationA Database Management System (DBMS) is a software package designed to store and manage database Functions Manages very large amount of data Supports efficent access to very large amount data Supports concurrent access to very large amount of Data Example: bank and its ATM machines, Internet application Supports secure, atomic access to very large amount of data People working with DBMS End users: query/update databases through application user interfaces Database designers: design database “schema” to model aspects of the real world Database appliaction developers: build applications that interface with databases Database administrators(a.k.a DBA’s): load, back up, and restore data, fine-tune databases for performance DBMS implementors: develop the DBMS or specialized data management software, implement new techniques for query processing and optimization inside DBMS Drawbacks of using file systems Data redundancy and inconsistency Difficulty in accessing data Data isolation - multiple files and formats Integrity problems Atomicity of updates Concurrent access by multiple users Security problems Why use a DBMS? Data independence and efficient access Reduced application development time Data integrity and security Uniform data administration Concurrent access, recover from crashes Database SystemsDefination A Database System (DBS) contains the following components Hardware platfom (PC/Workdstation/Cluster etc.) OS DBMS A (number of) database(s) DB APPs Data Models A collection of tools for describing Data structures Data relationships Data semantics Data constraints Entity-Relationship data model (mainly for database design) Relational model Object-based data models (Object-oriented and Object-relational) Semi-structured data model (XML) Other older models: Network model (e.g. IDS[Integrated Data Store]) Hierarchical model (e.g. IMS[Info. Management System]) Levels of Abstraction Physical level: describes how a record(e.g., employee) is stored. Logical level: describes data stored in database, and the relationships among the data. View level: application programs hide details of data types. Schemas and Instances Similar to types and value of variables in programming languages Schema - the logical structure of the database Example: The database consists of information about a set of customers and accounts and the relationship between them Analogous to type information of a variable in a program Physical schema: database design at the physical level Logical schema: database design at the logical level Instance - the actual content of the database at a particular point of time Analogous to the value of a variable Physical Data Independence - the ability to modify the physical schema without changing the logical schema Applications depend on the logical schema In general, the interfaces between the various levels and components should be well defined so that changes in some parts do not seriously influence others Data Manipulation Language (DML) Language for accessing and manipulating the data organized by the appropriate data model DML also known as query language Two classes of languages Procedual - user specifies what data is required and how to get those data Declarative (nonprocedural) - user specifies what data is required without specifying how to get those data SQL is the most widely used query language Data Definition Language (DLL) Specification notation for defining the database schema DDL compiler generates a set of tables stored in a data dictionary Data dictionary contains metadata (i.e., data about data) Database schema Data storage and definition language Specifies the storage structure and access methods used Integrity constraints Domain constraints Referential integrity (references constraint in SQL) Assertions Authorization Database DesignThe process of designing the general structure of the database: Logical Design - Deciding on the database schema. Database design requires that we find a “good” collection of relation schema. Business decision - What attributes should we record in the database? Computer Science decision - What relation schemas should we have and how should the attributes be distributed among the various relation schemas? Physical Design - Deciding on the physical layout of the database The Entity-Relationship Model Models an enterprise as collection of entities and relationships Entity (rectangle): a “thing” or “object” in the enterprise that is distinguishable from other objects Described by a set of attributes (ellipse) Relationship (diamond): an association among several entities Represented diagrammatically by an entity-relationship diagram Database System ArchitectureThe architecture of a database systems is greatly influenced by the underlying computer system on which the database is running: Centralized Client-server / Browser-server Parallel (multi-processor) Distributed Storage Management Storage manager is a program module that provides the interface between the low-level data stored in the database and the application programs and queries submitted to the system. The storage manager is responsible to the following tasks: Interaction with the file manager Efficient storing, retrieving and updating of data Issues: Storage access File organization Indexing and hashing Query Processing Parsing and translation Optimization Evaluation Alternative ways of evaluating a given query Equivalent expressions Different algorithms for each operation Cost difference between a good and a bad way of evaluating a query can be enormous Need to estimate the cost of operations Depends critically on statistical information about relations which the database must maintain Need to estimate statisics for intermediate results to compute cost of complex expressions Transaction Management A transaction is a collection of operations that performs a sgingle logical function in a database appliacation Transaction-management component ensures that the database remains in a consistent (correct) state despite system failures (e.g., power failures and operating system crashed) and transaction failures Concurrency-control manager controls the interaction among the concurrent transactions, to ensure the consistency of the database]]></content>
      <categories>
        <category>Database concept</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统CH-01]]></title>
    <url>%2F2019%2F05%2F12%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCH01%2F</url>
    <content type="text"><![CDATA[深入理解计算机系统CH-1 源程序源程序实际上由0和1组成的位（又称比特序列）序列，这些位被组织成8个一组，称为字节。每个字节都表示程序中某个文本字符。大部分现代系统都使用ASCII标准来表示文本字符。 基本思想：系统中所有的信息————包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。 编译系统执行四个阶段的程序（预处理器，编译器，汇编器和连接器）一起构成了编译系统 预处理阶段：预处理器(cpp)根据以字符#开头的命令修改原始c程序。如#include 即告知预处理器读取系统头文件stdio.h内容，将其插入程序文本，得到一个.i程序 编译阶段：编译器(ccl)将文本文件.i翻译成汇编程序文本文件.s，包含一个汇编语言程序 汇编阶段：汇编器(as)将.s文件翻译成机器语言指令，把这些指令打包成为一种叫做可重定位(relocatable)目标程序的格式，并将结果保存在目标文件.o(二进制文件)中。 链接阶段：链接器(ld)负责处理库中的函数以某种方式并入.o程序中，结果得到一个可执行目标文件。可执行文件加载到存储器，由系统负责执行。 编译系统益处 优化程序性能 理解链接时出现的错误 避免安全漏洞 系统硬件组成 总线：贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字(word)。 I/O设备：系统与外界的联系通道，例如USB控制器，图形适配器，硬盘控制器等。每个I/O设备都是通过一个控制器或适配器与I/O总现连接起来的。 主存：主存是一个临时存储设备，在处理器执行程序时，它被用来存放程序和程序处理的数据。物理上来说，是由一组DRAM(动态随机存储器)芯片组成。逻辑上来说，存储器是由一个线性的字节数组组成的，每个字节都有唯一的地址(数组索引)，这些地址是从零开始的。 处理器：中央处理单元(CPU)简称处理器，是解释(或执行)存储在主存中指令的引擎。处理器的核心是一个被称为程序计数器(PC)的字节大小的存储设备(或寄存器)。在任何一个时间点上，PC都指向主存中的某条机器语言指令(内含其地址)。 执行hello程序过程 在键盘中输入./hello后，shell逐一读取字符至寄存器。 按回车后，结束命令输入，将hello目标文件中的代码与数据拷至主存，加载hello文件。数据包括输出字符串。 加载完毕后，处理器执行主程序中的机器语言指令。这些指令将字符串中的字节从存储器中拷贝到寄存器文件，再从寄存器中文件拷贝到显示设备。 高速缓存针对处理器与主存存放字节数，读写速度以及运行速度的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器(cache memories，简称高速缓存) 存储设备的层次结构实际上，每个计算机系统中的存储设备都被组织成一个存储器层次模型。其主要思想是一个层次上的存储器作为下一层次上的存储器的高速缓存。利用对整个存储器层次模型的理解，可以提高程序的性能 操作系统管理硬件操作系统有两个基本功能： 防止硬件被失控的应用程序滥用 在控制复杂而又广泛不同的低级硬件设备方面，为应用程序提供简单一致的方法。 操作系统通过几个基本的抽象概念(进程、虚拟存储器和文件)实现这两个功能。 其中文件是对I/O设备的抽象表示，虚拟存储器是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。 进程操作系统运行程序的一种抽象。一个系统上可以同时运行多个进程，称之为并发运行。 实际上进程指令是交错执行的。操作系统实现交错执行的机制称为上下文切换(context switching)。 操作系统保存进程运行所需的所有状态信息，这种状态称之为上下文(context)。当操作系统决定从当前进程转移控制权到某个新进程时候，就会发生上下文切换。 线程一个进程可以由多个称为线程的执行单位组成，每个线程都运行进程的上下文中，并共享同样的模型和全局数据。 虚拟存储器虚拟存储器是一个抽象概念。每个进程看到的存储器是一致的，称为虚拟地址空间 每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。 程序代码和数据：由可执行文件目标直接初始化。 堆：堆可以在运行时候动态的扩展和收缩 共享库：存放共享库和数据的区域 栈：位于用户虚拟空间地址顶部，编译器用它来实现函数调用 内核虚拟存储器：内核是操作系统总是驻留在存储器中的部分 文件文件即是字节序列。]]></content>
      <tags>
        <tag>Computer System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 + Selenium + ChromeDriver 初探]]></title>
    <url>%2F2019%2F01%2F15%2Fselenium%2F</url>
    <content type="text"><![CDATA[简介Selenium是一个用于Web应用程序测试的工具。它直接运行在浏览器中，就像真正的用户在操作一样。运用这种特性，可以用于简单爬虫。 配置环境ChromeDriver下载相应版本的ChromeDriver，版本对应请看文件夹里面的note.txt文件。 Selenium1sudo pip3 install Selenium 模拟登录实现12345678910111213141516171819202122232425262728293031323334353637383940from selenium import webdriverimport osimport csvimport timeID = ""PASSWORD = ""chromedriver = "../Chrome_Driver/2.40/chromedriver"os.environ["webdriver.chrome.driver"] = chromedriverdriver = webdriver.Chrome(chromedriver)driver.get("http://jwxt.zufe.edu.cn/jwglxt/xtgl/login_slogin.html?language=zh_CN&amp;_t=1547536545893")inputID = driver.find_element_by_id("yhm")inputPASSWORD = driver.find_element_by_id("mm")clickButton = driver.find_element_by_id("dl")inputID.clear()inputPASSWORD.clear()inputID.send_keys(ID)inputPASSWORD.send_keys(PASSWORD)clickButton.click()driver.get("http://jwxt.zufe.edu.cn/jwglxt/cjcx/cjcx_cxDgXscj.html?gnmkdm=N305005&amp;layout=default&amp;su=%s" %ID)time.sleep(10)driver.find_element_by_id("search_go").click()table_rows = driver.find_element_by_tag_name("tbody").find_elements_by_tag_name("tr")rowsLen = len(table_rows)CSVPATH = "../Data/Score.csv"with open(CSVPATH,'w') as f: csv_write = csv.writer(f) csv_head = ["学年","学期","课程编号","课程名","课程类型","学分","成绩"] csv_write.writerow(csv_head) for i in range(1,rowsLen): csv_write.writerow(table_rows[i].text.split(" ")[1:8]) Socks Proxy12345678910111213141516from selenium import webdriverPORT = 1088chrome_options = webdriver.ChromeOptions()chrome_options.add_argument('--proxy-server=socks5://localhost:%s' %PORT)browser = webdriver.Chrome(chrome_options=chrome_options, executable_path='../Chrome_Driver/2.40/chromedriver')proxy.new_har('youtube')browser.get('http://www.google.com')browser.find_element_by_name("q")inputContent = browser.find_element_by_name("q")inputContent.clear()inputContent.send_keys("asmire.site")submit = browser.find_elements_by_name("btnK")submit[-1].click() 即可访问外网。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Josephus Problem]]></title>
    <url>%2F2018%2F09%2F09%2FThe-Josephus-Problem%2F</url>
    <content type="text"><![CDATA[简介约瑟夫问题： 据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。现在我们将问题一般化，即问题为： n个人围成一圈，从围成标记号为1到n的圆圈的n个人开始，每隔一个删去一个人，直到只有一个人幸存下来。求确定幸存者的号码 $J(n)$ 解法递归不妨从奇偶性开始考虑当$n$为偶数时，我们考虑 $J(2n)$ 的情况。第一轮后，还剩下n个人。此时发现编号符合映射: $x \rightarrow y = 2x-1$,可得到 $J(2n) = 2J(n)-1$同理，当 $n$ 为奇数时,我们考虑 $J(2n+1)$ 的情况，此时可得：$J(2n+1)=2J(n)+1$ 故定义$J$的递归式为： J(1) = 1J(2n) = 2J(n)-1, n\geq1J(2n+1) = 2J(n) + 1,n\geq1封闭形式通过递归式，我们可以观察解从而将递归式转化为封闭形式的解。 $n$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $J(n)$ 1 1 3 1 3 5 7 1 3 5 7 9 11 13 15 1 通过观察，如果我们将 $n$ 写成 $n=2^m+l$ ,则递归式解为： J(2^m+l) = 2l+1, m\geq0, 0\leq l < 2^m.约束条件为： 2^m\leq n\leq 2^{m+1}证明可用数学归纳法证明，此处略。 进制通过求解封闭形式，我们发现2的幂起着重要作用。于是研究以2为基数的表示方法。假设n的二进制展开式为 ${(b{_m}b_{m-1}b_{m-2}\cdots b_1b_0)}_2$ ，$b$ 取0或1，$b_m$=1.我们依次可得： n={(1b_{m-1}b_{m-2}\cdots b_1b_0)}_2l={(0b_{m-1}b_{m-2}\cdots b_1b_0)}_22l={(b_{m-1}b_{m-2}\cdots b_1b_00)}_22l+1={(b_{m-1}b_{m-2}\cdots b_1b_01)}_2J(n)={(b_{m-1}b_{m-2}\cdots b_1b_0b_m)}_2二进制下即可数位循环移动得到最终解。 扩展不动点若对 $J(n)$ 不断迭代，则最后会达到一个不动点，在该点有 $J(n)=n$.设 $J(n)$ 二进制中有k个1,则不断迭代后，$n=2^{k}-1$. 递归式通解f(1) = \alphaf(2n) = 2f(n) + \beta ,n \geq 1f(2n+1) = 2f(n) + \gamma ,n \geq 1对n的前几项列出表格 $n$ 1 2 3 4 5 6 $J(n)$ $\alpha$ $2\alpha+\beta+0\gamma$ $2\alpha+0\beta+1\gamma$ $4\alpha+3\beta+0\gamma$ $4\alpha+2\beta+1\gamma$ $4\alpha+1\beta+2\gamma$ 将 $f(n)$ 与 $\alpha,\beta,\gamma$ 的依存关系分离开来，表示为： f(n)=A(n)\alpha+B(n)\beta+C(n)\gamma可通过归纳法证得： A(n) = 2^mB(n) = 2^m-1-lC(n) = l其中有 $n=2^m+l$ 以及 $0\leq l&lt;2^m$ $(n\geq 1)$ 成套解法(repertoire method)从 $f(n)$ 出发，并研究是否有任意常数 $(\alpha,\beta,\gamma)$ 能定义它。 当 $f(n)=1$，可得解 $(\alpha,\beta,\gamma)=(1,-1,-1)$ , $A(n)-B(n)-C(n)=f(n)=1$同理当$ f(n)=n$ 时， $(\alpha,\beta,\gamma)=(1,0,1)$ 时对所有的n成立，故$ A(n)+C(n)=f(n)=n$ 可得： A(n) = 2^mA(n)-B(n)-C(n)=1A(n)+C(n)=n解同上. 进制通解令 $\beta_0 = \beta$ 以及 $\beta_1 = \gamma$，则推广递归式改写成 f(1) = \alphaf(2n+j) = 2f(n) + \beta_ j, j = 0,1,n\geq 1递归式由上两式按二进制展开为： f(n) = f((b_mb_{m-1}\cdots b_1b_0)_2) = 2^m\alpha +2^{m-1}\beta_{b_{m-1}}+\cdots+2\beta_{b_1}+\beta_{b_0}2^m\alpha +2^{m-1}\beta_{b_{m-1}}+\cdots+2\beta_{b_1}+\beta_{b_0} =(\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\cdots \beta_{b_1}\beta_{b_0})_2即 f(n)=(\alpha\beta_{b_{m-1}}\beta_{b_{m-2}}\cdots \beta_{b_1}\beta_{b_0})_2求解结束。以下给出例子$\alpha =1,\beta=-1,\gamma=1$,此时 $n=(1100100)_2 = 100$$f(n) = (1$ $ 1-1-1$ $1-1-1)_2 = +64 +32-16-8+4-2-1=73$]]></content>
      <categories>
        <category>Mathematics</category>
        <category>Concrete Mathematics</category>
      </categories>
      <tags>
        <tag>Concrete Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-NearestNeighbor]]></title>
    <url>%2F2018%2F08%2F20%2Fk-NearestNeighbor%2F</url>
    <content type="text"><![CDATA[简介KNN算法是测量不同特征值之间的距离方法进行分类和回归的非参数统计方法，属于懒惰学习(lazy learning)中的一种。 在k-NN分类中，输出是一个分类族群。一个对象的分类是由其邻居的“多数表决”确定的，k个最近邻居（k为正整数，通常较小）中最常见的分类决定了赋予该对象的类别。若 k = 1，则该对象的类别直接由最近的一个节点赋予。 在k-NN回归中，输出是该对象的属性值。该值是其k个最近邻居的值的平均值。 优点 精度高 对异常值不敏感 无数据输入假定 缺点 计算复杂度高、空间复杂度高。时间复杂度为 $O(n)$ 适用范围 该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。 数值型和标称型数据 注： 标称型：一般在有限的数据中取，而且只存在‘是’和‘否’两种不同的结果（一般用于分类）数值型：可以在无限的数据中取，而且数值比较具体化，例如4.02,6.23这种值（一般用于回归分析） 分类算法流程计算已知数据集中的点与当前点的距离12def classifyKNN(inX, dataSet, labels, k): diffMat = (np.tile(inx,(dataSet.shape[0],1)) - dataSet) ** 2 按照距离递增次序排序注: 这里使用欧式距离 12distance = (diffMat.sum(axis = 1)) ** 0.5sortedDistIndicies = distances.argsort() 注： x.argsort: 将x中的元素从小到大排列，提取其对应的index(索引)，然后输出到y。如 x = np.array([1,4,3,-1]), 则输出 array([3, 0, 2, 1]) 选取与当前点距离最小的k个点并统计类别频率12345classCount = &#123;&#125;for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #if label not in classCount,set 0,else it's count plus 1 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 返回前k个点频率最高的类别作为当前点的预测分类12sortedClassCount = sorted(classCount.iteritems(),key = operator.itemgetter(1), reverse = True)return sortedClassCount[0][0] 注: 迭代大数据字典时，如果是使用 items() 方法，那么在迭代之前，迭代器迭代前需要把数据完整地加载到内存，则会造成内存占用大。而 iteritem() 返回一个迭代器(iterators)，迭代器在迭代的时候，迭代元素逐个生成，减少了内存消耗。 分类完整代码123456789101112131415import numpy as npimport pandas as pdimport operator def KNNclassify(inx,dataSet,labels,k): diffMat = np.tile(inx, (dataSet.shape[0], 1)) - dataSet distances = ((diffMat**2).sum(axis = 1))**0.5 sortedDistIndicies = distances.argsort() classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #if voteIlabel not in classCount,set 0,else count plus 1 classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse = True) return sortedClassCount[0][0]]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Stat ML</category>
      </categories>
      <tags>
        <tag>Stat ML</tag>
      </tags>
  </entry>
</search>
